<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>libfoedus-core: foedus::cache Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libfoedus-core
   </div>
   <div id="projectbrief">FOEDUS Core Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="http://cihead.labs.hpe.com/centos7/"><span>Jenkins&#160;(x86_64&#160;Fedora)</span></a></li>
      <li><a href="http://cihead.labs.hpe.com/ub1404/"><span>Jenkins&#160;(x86_64&#160;Ubuntu)</span></a></li>
      <li><a href="http://ms01915-003.hpl.hp.com:8080/"><span>Jenkins&#160;(aarch64&#160;Ubuntu)</span></a></li>
      <li><a href="http://github.com/hkimura/foedus_code/tree/master"><span>Github</span></a></li>
      <li><a href="http://github.com/hkimura/foedus_code/wiki"><span>Wiki</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacefoedus_1_1cache.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">foedus::cache Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><b>Snapshot</b> <b>Cache</b> <b>Manager</b>, which caches data pages retrieved from snapshot files.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><b>Snapshot</b> <b>Cache</b> <b>Manager</b>, which caches data pages retrieved from snapshot files. </p>
<h1><a class="anchor" id="CACHE_OVERVIEW"></a>
Overview</h1>
<p>Snapshot Cache is a node-local read-only cache of snapshot pages. In some sense, it is a special kind of bufferpool that is much simpler and faster than traditional implementations due to the special requirements; no modifications, no interaction with logging module nor commit protocol, no guarantee needed for uniqueness (no problem to occasionally have two cached instances of the same page; just a bit waste of space). The operation to retrieve a snapshot page, especially when the page is in this cache, must be VERY fast. Thus, this cache manager must be highly optimized for read operations.</p>
<h1><a class="anchor" id="CACHE_STRUCTURE"></a>
Structure</h1>
<p>For each NUMA node memory, we have a hashtable structure whose key is snapshot-id/page-id and whose value is offset in cache memory. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoedus_1_1cache_1_1CacheBucket.html">CacheBucket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash bucket in cache table.  <a href="structfoedus_1_1cache_1_1CacheBucket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1cache_1_1CacheHashtable.html">CacheHashtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A NUMA-local hashtable of cached snapshot pages.  <a href="classfoedus_1_1cache_1_1CacheHashtable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1cache_1_1CacheManager.html">CacheManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snapshot cache manager.  <a href="classfoedus_1_1cache_1_1CacheManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1cache_1_1CacheManagerPimpl.html">CacheManagerPimpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pimpl object of <a class="el" href="classfoedus_1_1cache_1_1CacheManager.html" title="Snapshot cache manager. ">CacheManager</a>.  <a href="classfoedus_1_1cache_1_1CacheManagerPimpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoedus_1_1cache_1_1CacheOptions.html">CacheOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of options for snapshot cache manager.  <a href="structfoedus_1_1cache_1_1CacheOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structfoedus_1_1cache_1_1CacheOverflowEntry"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefoedus_1_1cache.html#structfoedus_1_1cache_1_1CacheOverflowEntry">CacheOverflowEntry</a></td></tr>
<tr class="memdesc:structfoedus_1_1cache_1_1CacheOverflowEntry"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entry in the overflow linked list for snapshot cache.  <a href="namespacefoedus_1_1cache.html#structfoedus_1_1cache_1_1CacheOverflowEntry">More...</a><br /></td></tr>
<tr class="separator:structfoedus_1_1cache_1_1CacheOverflowEntry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoedus_1_1cache_1_1CacheRefCount.html">CacheRefCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A loosely maintained reference count for CLOCK algorithm.  <a href="structfoedus_1_1cache_1_1CacheRefCount.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoedus_1_1cache_1_1HashFunc.html">HashFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple hash function logic used in snasphot cache.  <a href="structfoedus_1_1cache_1_1HashFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1cache_1_1SnapshotFileSet.html">SnapshotFileSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a set of read-only file objects for snapshot files.  <a href="classfoedus_1_1cache_1_1SnapshotFileSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abfca49eb29e5129b80bf087c7b9cfaa7"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefoedus_1_1cache.html#abfca49eb29e5129b80bf087c7b9cfaa7">BucketId</a></td></tr>
<tr class="memdesc:abfca49eb29e5129b80bf087c7b9cfaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset in hashtable bucket.  <a href="#abfca49eb29e5129b80bf087c7b9cfaa7">More...</a><br /></td></tr>
<tr class="separator:abfca49eb29e5129b80bf087c7b9cfaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90670494c3a525f4921b61d4e06ca369"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__MEMORY.html#gaf7ed7c23d184b14ce978b1775a86dfae">memory::PagePoolOffset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefoedus_1_1cache.html#a90670494c3a525f4921b61d4e06ca369">ContentId</a></td></tr>
<tr class="memdesc:a90670494c3a525f4921b61d4e06ca369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of the actual page image in PagePool for snapshot pages.  <a href="#a90670494c3a525f4921b61d4e06ca369">More...</a><br /></td></tr>
<tr class="separator:a90670494c3a525f4921b61d4e06ca369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e55979322d3cfceff78e1f77d901a82"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefoedus_1_1cache.html#a9e55979322d3cfceff78e1f77d901a82">PageIdTag</a></td></tr>
<tr class="memdesc:a9e55979322d3cfceff78e1f77d901a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a lossy-compressed representation of SnapshotPagePointer used to quickly identify whether the content of a bucket <em>may</em> represent the given SnapshotPagePointer or not.  <a href="#a9e55979322d3cfceff78e1f77d901a82">More...</a><br /></td></tr>
<tr class="separator:a9e55979322d3cfceff78e1f77d901a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1f26fae41d62d8c2db91322b4f5466"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefoedus_1_1cache.html#a2d1f26fae41d62d8c2db91322b4f5466">OverflowPointer</a></td></tr>
<tr class="memdesc:a2d1f26fae41d62d8c2db91322b4f5466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position in the overflow buckets.  <a href="#a2d1f26fae41d62d8c2db91322b4f5466">More...</a><br /></td></tr>
<tr class="separator:a2d1f26fae41d62d8c2db91322b4f5466"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9b43ef6b796c99e0e4188af14667c571"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefoedus_1_1cache.html#abfca49eb29e5129b80bf087c7b9cfaa7">BucketId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefoedus_1_1cache.html#a9b43ef6b796c99e0e4188af14667c571">determine_logical_buckets</a> (<a class="el" href="namespacefoedus_1_1cache.html#abfca49eb29e5129b80bf087c7b9cfaa7">BucketId</a> physical_buckets)</td></tr>
<tr class="separator:a9b43ef6b796c99e0e4188af14667c571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75ca4bf05b56cb8ee86740875a0d173"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefoedus_1_1cache.html#ab75ca4bf05b56cb8ee86740875a0d173">determine_overflow_list_size</a> (<a class="el" href="namespacefoedus_1_1cache.html#abfca49eb29e5129b80bf087c7b9cfaa7">BucketId</a> physical_buckets)</td></tr>
<tr class="separator:ab75ca4bf05b56cb8ee86740875a0d173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d622c86a170e5615c419b48eeabd047"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefoedus_1_1cache.html#a7d622c86a170e5615c419b48eeabd047">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="structfoedus_1_1cache_1_1HashFunc.html">HashFunc</a> &amp;v)</td></tr>
<tr class="separator:a7d622c86a170e5615c419b48eeabd047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796bf13f68a7df8c758dc81443392001"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefoedus_1_1cache.html#a796bf13f68a7df8c758dc81443392001">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classfoedus_1_1cache_1_1SnapshotFileSet.html">SnapshotFileSet</a> &amp;v)</td></tr>
<tr class="separator:a796bf13f68a7df8c758dc81443392001"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a56bdc23db45d170f73d6558b12ffab5a"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefoedus_1_1cache.html#a56bdc23db45d170f73d6558b12ffab5a">kHopNeighbors</a> = 16U</td></tr>
<tr class="memdesc:a56bdc23db45d170f73d6558b12ffab5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting from the given position, we consider this many buckets for the entry.  <a href="#a56bdc23db45d170f73d6558b12ffab5a">More...</a><br /></td></tr>
<tr class="separator:a56bdc23db45d170f73d6558b12ffab5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structfoedus_1_1cache_1_1CacheOverflowEntry" id="structfoedus_1_1cache_1_1CacheOverflowEntry"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct foedus::cache::CacheOverflowEntry</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>An entry in the overflow linked list for snapshot cache. </p>
<p>Entries that didn't find an empty slot are soted in a single linked list. There should be very few entries that go in the linked list. It should be almost empty. As the size of bucket is negligibly smaller than the actual page anyway (8-bytes vs 4kb), we allocate a generous (16x-ish) number of buckets compared to the total count of pages. The hashtable is guaranteed to be very sparse. We don't need anything advanced. Simple stupid. </p>

<p>Definition at line <a class="el" href="cache__hashtable_8hpp_source.html#l00191">191</a> of file <a class="el" href="cache__hashtable_8hpp_source.html">cache_hashtable.hpp</a>.</p>
</div><div class="dynheader">
Collaboration diagram for foedus::cache::CacheOverflowEntry:</div>
<div class="dyncontent">
<div class="center"><img src="structfoedus_1_1cache_1_1CacheOverflowEntry__coll__graph.png" border="0" usemap="#foedus_1_1cache_1_1CacheOverflowEntry_coll__map" alt="Collaboration graph"/></div>
<map name="foedus_1_1cache_1_1CacheOverflowEntry_coll__map" id="foedus_1_1cache_1_1CacheOverflowEntry_coll__map">
<area shape="rect" id="node2" href="structfoedus_1_1cache_1_1CacheBucket.html" title="Hash bucket in cache table. " alt="" coords="5,5,195,32"/>
<area shape="rect" id="node3" href="structfoedus_1_1cache_1_1CacheRefCount.html" title="A loosely maintained reference count for CLOCK algorithm. " alt="" coords="219,5,421,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a60ed7dceb59de97100cce445f5dbcd3a"></a><a class="el" href="structfoedus_1_1cache_1_1CacheBucket.html">CacheBucket</a></td>
<td class="fieldname">
bucket_</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae12719ddad39c1aaac04a294fe0dea3f"></a><a class="el" href="namespacefoedus_1_1cache.html#a2d1f26fae41d62d8c2db91322b4f5466">OverflowPointer</a></td>
<td class="fieldname">
next_</td>
<td class="fielddoc">
Note that we don't have to atomically maintain/follow this pointer thanks to the loose requirements. <p>If we miss an entry, it's just a cache miss. If we couldn't evict some page, it's just one page of wasted DRAM. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a31235fb6af483bc6a9fed7897987208d"></a>uint16_t</td>
<td class="fieldname">
padding_</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac6b943d816bc16689f894a7b735bb861"></a><a class="el" href="structfoedus_1_1cache_1_1CacheRefCount.html">CacheRefCount</a></td>
<td class="fieldname">
refcount_</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="abfca49eb29e5129b80bf087c7b9cfaa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacefoedus_1_1cache.html#abfca49eb29e5129b80bf087c7b9cfaa7">foedus::cache::BucketId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset in hashtable bucket. </p>

<p>Definition at line <a class="el" href="cache__hashtable_8hpp_source.html#l00049">49</a> of file <a class="el" href="cache__hashtable_8hpp_source.html">cache_hashtable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a90670494c3a525f4921b61d4e06ca369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__MEMORY.html#gaf7ed7c23d184b14ce978b1775a86dfae">memory::PagePoolOffset</a> <a class="el" href="namespacefoedus_1_1cache.html#a90670494c3a525f4921b61d4e06ca369">foedus::cache::ContentId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset of the actual page image in PagePool for snapshot pages. </p>
<p>0 means not set yet.</p>
<p>As each page is 4kb and we expect to spend GBs of DRAM for snapshot cache, the table will have many millions of buckets. However, we can probably assume that the size is within 32 bit. Even with 50% fullness, 2^32 / 2 * 4kb = 8TB. We will not have that much DRAM per NUMA node. </p>

<p>Definition at line <a class="el" href="cache__hashtable_8hpp_source.html#l00058">58</a> of file <a class="el" href="cache__hashtable_8hpp_source.html">cache_hashtable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d1f26fae41d62d8c2db91322b4f5466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacefoedus_1_1cache.html#a2d1f26fae41d62d8c2db91322b4f5466">foedus::cache::OverflowPointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position in the overflow buckets. </p>
<p>Index-0 is always unused, thus it means null. </p>

<p>Definition at line <a class="el" href="cache__hashtable_8hpp_source.html#l00072">72</a> of file <a class="el" href="cache__hashtable_8hpp_source.html">cache_hashtable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e55979322d3cfceff78e1f77d901a82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacefoedus_1_1cache.html#a9e55979322d3cfceff78e1f77d901a82">foedus::cache::PageIdTag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a lossy-compressed representation of SnapshotPagePointer used to quickly identify whether the content of a bucket <em>may</em> represent the given SnapshotPagePointer or not. </p>
<p>This value is calculated via another simple formula, which should be as independent as possible from hash function (otherwise it can't differentiate entries with similar hash values). This value avoids 0 for sanity checks. If our formula results in 0, we change it to 1. </p>

<p>Definition at line <a class="el" href="cache__hashtable_8hpp_source.html#l00067">67</a> of file <a class="el" href="cache__hashtable_8hpp_source.html">cache_hashtable.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9b43ef6b796c99e0e4188af14667c571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefoedus_1_1cache.html#abfca49eb29e5129b80bf087c7b9cfaa7">BucketId</a> foedus::cache::determine_logical_buckets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacefoedus_1_1cache.html#abfca49eb29e5129b80bf087c7b9cfaa7">BucketId</a>&#160;</td>
          <td class="paramname"><em>physical_buckets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cache__hashtable_8cpp_source.html#l00035">35</a> of file <a class="el" href="cache__hashtable_8cpp_source.html">cache_hashtable.cpp</a>.</p>

<p>References <a class="el" href="assert__nd_8hpp_source.html#l00072">ASSERT_ND</a>, <a class="el" href="assorted__func_8cpp_source.html#l00164">foedus::assorted::generate_almost_prime_below()</a>, and <a class="el" href="cache__hashtable_8hpp_source.html#l00080">kHopNeighbors</a>.</p>
<div class="fragment"><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                                                              {</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <a class="code" href="group__IDIOMS.html#gaa5c1d074da423c0f330d1bc8a098ecb8">ASSERT_ND</a>(physical_buckets &gt;= 1024U);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <span class="comment">// to speed up, leave space in neighbors of the last bucket.</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="comment">// Instead, we do not wrap-around.</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  <span class="comment">// Also, leave space for at least one cacheline so that we never overrun when we prefetch.</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <a class="code" href="namespacefoedus_1_1cache.html#abfca49eb29e5129b80bf087c7b9cfaa7">BucketId</a> buckets = physical_buckets - <a class="code" href="namespacefoedus_1_1cache.html#a56bdc23db45d170f73d6558b12ffab5a">kHopNeighbors</a> - 64ULL;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <span class="comment">// to make the division-hashing more effective, make it prime-like.</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  <a class="code" href="namespacefoedus_1_1cache.html#abfca49eb29e5129b80bf087c7b9cfaa7">BucketId</a> logical_buckets = <a class="code" href="group__ASSORTED.html#ga7fca9a740f557f4f79df89e3d416db31">assorted::generate_almost_prime_below</a>(buckets);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  <a class="code" href="group__IDIOMS.html#gaa5c1d074da423c0f330d1bc8a098ecb8">ASSERT_ND</a>(logical_buckets &lt;= physical_buckets);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  <a class="code" href="group__IDIOMS.html#gaa5c1d074da423c0f330d1bc8a098ecb8">ASSERT_ND</a>((logical_buckets &amp; (logical_buckets - 1U)) != 0);  <span class="comment">// at least not power of 2</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <span class="keywordflow">return</span> logical_buckets;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div>
<div class="ttc" id="namespacefoedus_1_1cache_html_abfca49eb29e5129b80bf087c7b9cfaa7"><div class="ttname"><a href="namespacefoedus_1_1cache.html#abfca49eb29e5129b80bf087c7b9cfaa7">foedus::cache::BucketId</a></div><div class="ttdeci">uint32_t BucketId</div><div class="ttdoc">Offset in hashtable bucket. </div><div class="ttdef"><b>Definition:</b> <a href="cache__hashtable_8hpp_source.html#l00049">cache_hashtable.hpp:49</a></div></div>
<div class="ttc" id="namespacefoedus_1_1cache_html_a56bdc23db45d170f73d6558b12ffab5a"><div class="ttname"><a href="namespacefoedus_1_1cache.html#a56bdc23db45d170f73d6558b12ffab5a">foedus::cache::kHopNeighbors</a></div><div class="ttdeci">const uint16_t kHopNeighbors</div><div class="ttdoc">Starting from the given position, we consider this many buckets for the entry. </div><div class="ttdef"><b>Definition:</b> <a href="cache__hashtable_8hpp_source.html#l00080">cache_hashtable.hpp:80</a></div></div>
<div class="ttc" id="group__ASSORTED_html_ga7fca9a740f557f4f79df89e3d416db31"><div class="ttname"><a href="group__ASSORTED.html#ga7fca9a740f557f4f79df89e3d416db31">foedus::assorted::generate_almost_prime_below</a></div><div class="ttdeci">uint64_t generate_almost_prime_below(uint64_t threshold)</div><div class="ttdoc">Generate a prime or some number that is almost prime less than the given number. </div><div class="ttdef"><b>Definition:</b> <a href="assorted__func_8cpp_source.html#l00164">assorted_func.cpp:164</a></div></div>
<div class="ttc" id="group__IDIOMS_html_gaa5c1d074da423c0f330d1bc8a098ecb8"><div class="ttname"><a href="group__IDIOMS.html#gaa5c1d074da423c0f330d1bc8a098ecb8">ASSERT_ND</a></div><div class="ttdeci">#define ASSERT_ND(x)</div><div class="ttdoc">A warning-free wrapper macro of assert() that has no performance effect in release mode even when &#39;x&#39;...</div><div class="ttdef"><b>Definition:</b> <a href="assert__nd_8hpp_source.html#l00072">assert_nd.hpp:72</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacefoedus_1_1cache_a9b43ef6b796c99e0e4188af14667c571_cgraph.png" border="0" usemap="#namespacefoedus_1_1cache_a9b43ef6b796c99e0e4188af14667c571_cgraph" alt=""/></div>
<map name="namespacefoedus_1_1cache_a9b43ef6b796c99e0e4188af14667c571_cgraph" id="namespacefoedus_1_1cache_a9b43ef6b796c99e0e4188af14667c571_cgraph">
<area shape="rect" id="node2" href="group__ASSORTED.html#ga7fca9a740f557f4f79df89e3d416db31" title="Generate a prime or some number that is almost prime less than the given number. " alt="" coords="221,5,397,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab75ca4bf05b56cb8ee86740875a0d173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t foedus::cache::determine_overflow_list_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacefoedus_1_1cache.html#abfca49eb29e5129b80bf087c7b9cfaa7">BucketId</a>&#160;</td>
          <td class="paramname"><em>physical_buckets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cache__hashtable_8cpp_source.html#l00049">49</a> of file <a class="el" href="cache__hashtable_8cpp_source.html">cache_hashtable.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                                                                 {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  <span class="comment">// there should be very few overflow entries. This can be super small.</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="keyword">const</span> uint32_t kOverflowFraction = 128U;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  <span class="keyword">const</span> uint32_t kOverflowMinSize = 256U;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  uint32_t overflow_size = physical_buckets / kOverflowFraction;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  <span class="keywordflow">if</span> (overflow_size &lt;= kOverflowMinSize) {</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    overflow_size = kOverflowMinSize;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  }</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="keywordflow">return</span> overflow_size;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a796bf13f68a7df8c758dc81443392001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; foedus::cache::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfoedus_1_1cache_1_1SnapshotFileSet.html">SnapshotFileSet</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="snapshot__file__set_8cpp_source.html#l00127">127</a> of file <a class="el" href="snapshot__file__set_8cpp_source.html">snapshot_file_set.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                                                                {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  o &lt;&lt; <span class="stringliteral">&quot;&lt;SnapshotFileSet&gt;&quot;</span>;</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; snapshot : v.files_) {</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    o &lt;&lt; <span class="stringliteral">&quot;&lt;snapshot id=\&quot;&quot;</span> &lt;&lt; snapshot.first &lt;&lt; <span class="stringliteral">&quot;\&quot;&gt;&quot;</span>;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; entry : snapshot.second) {</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;      o &lt;&lt; <span class="stringliteral">&quot;&lt;node id=\&quot;&quot;</span> &lt;&lt; entry.first</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;\&quot; fd=\&quot;&quot;</span> &lt;&lt; entry.second-&gt;get_descriptor() &lt;&lt; <span class="stringliteral">&quot;\&quot; /&gt;&quot;</span>;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    }</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    o &lt;&lt; <span class="stringliteral">&quot;&lt;/snapshot&gt;&quot;</span>;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  }</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  <span class="keywordflow">return</span> o;</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7d622c86a170e5615c419b48eeabd047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; foedus::cache::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfoedus_1_1cache_1_1HashFunc.html">HashFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cache__hashtable_8cpp_source.html#l00332">332</a> of file <a class="el" href="cache__hashtable_8cpp_source.html">cache_hashtable.cpp</a>.</p>

<p>References <a class="el" href="cache__hashtable_8hpp_source.html#l00092">foedus::cache::HashFunc::logical_buckets_</a>, and <a class="el" href="cache__hashtable_8hpp_source.html#l00094">foedus::cache::HashFunc::physical_buckets_</a>.</p>
<div class="fragment"><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                                                         {</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  o &lt;&lt; <span class="stringliteral">&quot;&lt;HashFunc&gt;&quot;</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    &lt;&lt; <span class="stringliteral">&quot;&lt;logical_buckets_&gt;&quot;</span> &lt;&lt; v.logical_buckets_ &lt;&lt; <span class="stringliteral">&quot;&lt;logical_buckets_&gt;&quot;</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    &lt;&lt; <span class="stringliteral">&quot;&lt;physical_buckets_&gt;&quot;</span> &lt;&lt; v.physical_buckets_ &lt;&lt; <span class="stringliteral">&quot;&lt;physical_buckets_&gt;&quot;</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    &lt;&lt; <span class="stringliteral">&quot;&lt;/HashFunc&gt;&quot;</span>;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;  <span class="keywordflow">return</span> o;</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a56bdc23db45d170f73d6558b12ffab5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t foedus::cache::kHopNeighbors = 16U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting from the given position, we consider this many buckets for the entry. </p>
<p>When there is no empty bucket, the entry goes to the overflow linked-list. Setting a larger number means we have to read this many buckets at least for cache-miss case. It is anyway cheap because it's a sequential read, but still must not be too large. </p>

<p>Definition at line <a class="el" href="cache__hashtable_8hpp_source.html#l00080">80</a> of file <a class="el" href="cache__hashtable_8hpp_source.html">cache_hashtable.hpp</a>.</p>

<p>Referenced by <a class="el" href="cache__hashtable_8cpp_source.html#l00035">determine_logical_buckets()</a>, <a class="el" href="cache__hashtable_8hpp_source.html#l00415">foedus::cache::CacheHashtable::find()</a>, <a class="el" href="cache__hashtable_8cpp_source.html#l00376">foedus::cache::CacheHashtable::find_batch()</a>, and <a class="el" href="cache__hashtable_8cpp_source.html#l00114">foedus::cache::CacheHashtable::install()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefoedus.html">foedus</a></li><li class="navelem"><a class="el" href="namespacefoedus_1_1cache.html">cache</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
