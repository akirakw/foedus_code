<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>libfoedus-core: Sequential Storage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libfoedus-core
   </div>
   <div id="projectbrief">FOEDUS Core Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="http://cihead.labs.hpe.com/centos7/"><span>Jenkins&#160;(x86_64&#160;Fedora)</span></a></li>
      <li><a href="http://cihead.labs.hpe.com/ub1404/"><span>Jenkins&#160;(x86_64&#160;Ubuntu)</span></a></li>
      <li><a href="http://ms01915-003.hpl.hp.com:8080/"><span>Jenkins&#160;(aarch64&#160;Ubuntu)</span></a></li>
      <li><a href="http://github.com/hkimura/foedus_code/tree/master"><span>Github</span></a></li>
      <li><a href="http://github.com/hkimura/foedus_code/wiki"><span>Wiki</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__SEQUENTIAL.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Sequential Storage<div class="ingroups"><a class="el" href="group__COMPONENTS.html">FOEDUS Components</a> &raquo; <a class="el" href="group__STORAGE.html">Storage Manager</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><b>Sequential</b> Storage, an append/scan only data structure.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><b>Sequential</b> Storage, an append/scan only data structure. </p>
<p>This data structure is also called <em>Heap</em> in database literature, but probably not a good naming (Heap usually means min/max Heap, which is totally different). So, we call this data structure as Sequential Storage.</p>
<h1><a class="anchor" id="SEQ_BASICS"></a>
Basic Structure and Supported Operations</h1>
<p>A sequential storage is <b>VERY</b> simple thus efficient. The only access pattern is <em>append</em> and <em>scan</em>, which makes everything simple. Further, the scan does not provide any guarantee in ordering (similar to Heap in DBMS). It just returns records in the order the underlying storage natively stores them.</p>
<h1><a class="anchor" id="SEQ_HIE"></a>
Page Hierarchy</h1>
<p>There are only two types of pages; <b>root</b> pages (<a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialRootPage.html" title="Represents one stable root page in Sequential Storage. ">foedus::storage::sequential::SequentialRootPage</a>) and <b>data</b> pages (<a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialPage.html" title="Represents one data page in Sequential Storage. ">foedus::storage::sequential::SequentialPage</a>).</p>
<p>Root pages are merely a set of pointers to <em>head</em> pages, which are the beginnings of singly-linked list of data pages.</p>
<p>All contents of root pages are stable. They are never dynamically changed. The volatile part of <a class="el" href="group__SEQUENTIAL.html">Sequential Storage</a> is maintained as a set of singly-linked list pointed directly from the storage object, so there is no root page for it.</p>
<p>Data pages contain records that are contiguously placed each other. They form a singly linked list starting from a head page.</p>
<p>For each snapshotting, we add a new set of head pages (one for each node) and pointers to them from the root page. As root pages are singly-linked list, we re-write entire root pages for every sequential storage that had some change for each snapshotting (*). Unless there are huge number of head pages, this should be a negligible overhead.</p>
<p>(*) We only are placing a few head page pointers at the last root page only, but that means we have to install a new version of the last root page, which requires installing a new version of the second-to-last root page just for changing the next pointer, which requires... But, again, most sequential storage's root page should be just one or two pages. A similar overhead happens to all other storage types, too.</p>
<h1><a class="anchor" id="SEQ_LAYOUT"></a>
Page Layout</h1>
<p>Both data pages and root pages form a singly linked list of pages. The next pointer is stored in the header part.</p>
<h2><a class="anchor" id="SEQ_LAYOUT_DATA"></a>
Layout of Data Page (foedus::storage::sequential::SequentialPage)</h2>
<table class="doxtable">
<tr>
<th>Fix-Sized HEADER (kHeaderSize bytes) </th></tr>
<tr>
<td>Record Data part, which grows forward </td></tr>
<tr>
<th>Unused part </th></tr>
<tr>
<td>Record Lengthes part, which grows backward </td></tr>
</table>
<h2><a class="anchor" id="SEQ_LAYOUT_ROOT"></a>
Layout of Root Page (foedus::storage::sequential::SequentialRootPage)</h2>
<table class="doxtable">
<tr>
<th>Fix-Sized HEADER (kRootPageHeaderSize bytes) </th></tr>
<tr>
<td>Pointers to head pages.. </td></tr>
</table>
<h1><a class="anchor" id="SEQ_INMEM"></a>
In-memory List</h1>
<p>As described above, the volatile part of sequential storage is a set of singly-linked list pointed directly from the storage object. The storage object maintains such in-memory list for each epoch. When snapshotting happens, it retires those lists whose epochs are upto the snapshot's "until" epoch.</p>
<p>Because we have to efficiently append to the in-memory list, we maintain head and tail pointers to each list. Updating the tail page and replacing tail pointers involve a few atomic operations, but no expensive locks as done in other storages. For more details, see SequentialVolatileList. </p>
<div class="dynheader">
Collaboration diagram for Sequential Storage:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__SEQUENTIAL.png" border="0" alt="" usemap="#group____SEQUENTIAL"/>
<map name="group____SEQUENTIAL" id="group____SEQUENTIAL">
<area shape="rect" id="node1" href="group__STORAGE.html" title="Storage Manager, which implements a couple of key/value stores. " alt="" coords="5,51,127,77"/>
<area shape="rect" id="node2" href="group__LOGTYPE.html" title="Defines the content and apply logic of transactional operatrions. " alt="" coords="524,51,605,77"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:storage_2sequential_2fwd_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage_2sequential_2fwd_8hpp.html">fwd.hpp</a></td></tr>
<tr class="memdesc:storage_2sequential_2fwd_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declarations of classes in sequential storage package. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sequential__id_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sequential__id_8hpp.html">sequential_id.hpp</a></td></tr>
<tr class="memdesc:sequential__id_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of IDs in this package and a few related constant values. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sequential__log__types_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sequential__log__types_8hpp.html">sequential_log_types.hpp</a></td></tr>
<tr class="memdesc:sequential__log__types_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares all log types used in this storage type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structfoedus_1_1storage_1_1sequential_1_1SequentialComposer_1_1RootInfoPage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SEQUENTIAL.html#structfoedus_1_1storage_1_1sequential_1_1SequentialComposer_1_1RootInfoPage">foedus::storage::sequential::SequentialComposer::RootInfoPage</a></td></tr>
<tr class="memdesc:structfoedus_1_1storage_1_1sequential_1_1SequentialComposer_1_1RootInfoPage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output of one <a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialComposer.html#a3e005713f9a1c12bb2a4771a192b47a5">compose()</a> call, which are then combined in <a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialComposer.html#a91db842a6ef8780d3fe4ba2f0f625da7">construct_root()</a>.  <a href="group__SEQUENTIAL.html#structfoedus_1_1storage_1_1sequential_1_1SequentialComposer_1_1RootInfoPage">More...</a><br /></td></tr>
<tr class="separator:structfoedus_1_1storage_1_1sequential_1_1SequentialComposer_1_1RootInfoPage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialComposer.html">foedus::storage::sequential::SequentialComposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfoedus_1_1storage_1_1Composer.html" title="Represents a logic to compose a new version of data pages for one storage. ">Composer</a> for an sequential storage.  <a href="classfoedus_1_1storage_1_1sequential_1_1SequentialComposer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialCursor.html">foedus::storage::sequential::SequentialCursor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cursor interface to read tuples from a sequential storage.  <a href="classfoedus_1_1storage_1_1sequential_1_1SequentialCursor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoedus_1_1storage_1_1sequential_1_1SequentialRecordBatch.html">foedus::storage::sequential::SequentialRecordBatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A chunk of records returned by <a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialCursor.html" title="A cursor interface to read tuples from a sequential storage. ">SequentialCursor</a>.  <a href="structfoedus_1_1storage_1_1sequential_1_1SequentialRecordBatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialRecordIterator.html">foedus::storage::sequential::SequentialRecordIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for one <a class="el" href="structfoedus_1_1storage_1_1sequential_1_1SequentialRecordBatch.html" title="A chunk of records returned by SequentialCursor. ">SequentialRecordBatch</a>, or a page.  <a href="classfoedus_1_1storage_1_1sequential_1_1SequentialRecordIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structfoedus_1_1storage_1_1sequential_1_1HeadPagePointer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SEQUENTIAL.html#structfoedus_1_1storage_1_1sequential_1_1HeadPagePointer">foedus::storage::sequential::HeadPagePointer</a></td></tr>
<tr class="memdesc:structfoedus_1_1storage_1_1sequential_1_1HeadPagePointer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each pointer to a snapshot head page comes with a bit more information to help reading.  <a href="group__SEQUENTIAL.html#structfoedus_1_1storage_1_1sequential_1_1HeadPagePointer">More...</a><br /></td></tr>
<tr class="separator:structfoedus_1_1storage_1_1sequential_1_1HeadPagePointer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoedus_1_1storage_1_1sequential_1_1SequentialCreateLogType.html">foedus::storage::sequential::SequentialCreateLogType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log type of CREATE SEQUENTIAL STORAGE operation.  <a href="structfoedus_1_1storage_1_1sequential_1_1SequentialCreateLogType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoedus_1_1storage_1_1sequential_1_1SequentialTruncateLogType.html">foedus::storage::sequential::SequentialTruncateLogType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log type of TRUNCATE SEQUENTIAL STORAGE operation.  <a href="structfoedus_1_1storage_1_1sequential_1_1SequentialTruncateLogType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoedus_1_1storage_1_1sequential_1_1SequentialMetadata.html">foedus::storage::sequential::SequentialMetadata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structfoedus_1_1storage_1_1Metadata.html" title="Metadata of one storage. ">Metadata</a> of a sequential storage.  <a href="structfoedus_1_1storage_1_1sequential_1_1SequentialMetadata.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialPage.html">foedus::storage::sequential::SequentialPage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents one data page in <a class="el" href="group__SEQUENTIAL.html">Sequential Storage</a>.  <a href="classfoedus_1_1storage_1_1sequential_1_1SequentialPage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialRootPage.html">foedus::storage::sequential::SequentialRootPage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents one stable root page in <a class="el" href="group__SEQUENTIAL.html">Sequential Storage</a>.  <a href="classfoedus_1_1storage_1_1sequential_1_1SequentialRootPage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialPartitioner.html">foedus::storage::sequential::SequentialPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfoedus_1_1storage_1_1Partitioner.html" title="Partitioning and sorting logic for one storage. ">Partitioner</a> for an sequential storage.  <a href="classfoedus_1_1storage_1_1sequential_1_1SequentialPartitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialStorage.html">foedus::storage::sequential::SequentialStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an append/scan-only store.  <a href="classfoedus_1_1storage_1_1sequential_1_1SequentialStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structfoedus_1_1storage_1_1sequential_1_1SequentialStoragePimpl_1_1PointerPage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SEQUENTIAL.html#structfoedus_1_1storage_1_1sequential_1_1SequentialStoragePimpl_1_1PointerPage">foedus::storage::sequential::SequentialStoragePimpl::PointerPage</a></td></tr>
<tr class="separator:structfoedus_1_1storage_1_1sequential_1_1SequentialStoragePimpl_1_1PointerPage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialStoragePimpl.html">foedus::storage::sequential::SequentialStoragePimpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free list of records stored in the volatile part of sequential storage.  <a href="classfoedus_1_1storage_1_1sequential_1_1SequentialStoragePimpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga36d21c8cb7de29e785b06a6f4ac3355a"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SEQUENTIAL.html#ga36d21c8cb7de29e785b06a6f4ac3355a">foedus::storage::sequential::kMaxSlots</a> = 1 &lt;&lt; 15</td></tr>
<tr class="memdesc:ga36d21c8cb7de29e785b06a6f4ac3355a"><td class="mdescLeft">&#160;</td><td class="mdescRight">We have to represent the record count in 15 bits.  <a href="group__SEQUENTIAL.html#ga36d21c8cb7de29e785b06a6f4ac3355a">More...</a><br /></td></tr>
<tr class="separator:ga36d21c8cb7de29e785b06a6f4ac3355a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133b3b55748b6abc8d3e28e4204753a5"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SEQUENTIAL.html#ga133b3b55748b6abc8d3e28e4204753a5">foedus::storage::sequential::kHeaderSize</a> = 64</td></tr>
<tr class="memdesc:ga133b3b55748b6abc8d3e28e4204753a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte size of header in each data page of sequential storage.  <a href="group__SEQUENTIAL.html#ga133b3b55748b6abc8d3e28e4204753a5">More...</a><br /></td></tr>
<tr class="separator:ga133b3b55748b6abc8d3e28e4204753a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45253b9b10362dcea0c1c313dd4cdd28"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SEQUENTIAL.html#ga45253b9b10362dcea0c1c313dd4cdd28">foedus::storage::sequential::kDataSize</a> = <a class="el" href="group__STORAGE.html#ga1a3c05fe1d44455fc3e761947c6e21e6">foedus::storage::kPageSize</a> - kHeaderSize</td></tr>
<tr class="memdesc:ga45253b9b10362dcea0c1c313dd4cdd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte size of data region in each data page of sequential storage.  <a href="group__SEQUENTIAL.html#ga45253b9b10362dcea0c1c313dd4cdd28">More...</a><br /></td></tr>
<tr class="separator:ga45253b9b10362dcea0c1c313dd4cdd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga976717e2d78b52aec5e8d9657093a5e7"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SEQUENTIAL.html#ga976717e2d78b52aec5e8d9657093a5e7">foedus::storage::sequential::kMaxPayload</a> = kDataSize</td></tr>
<tr class="memdesc:ga976717e2d78b52aec5e8d9657093a5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Payload must be shorter than this length.  <a href="group__SEQUENTIAL.html#ga976717e2d78b52aec5e8d9657093a5e7">More...</a><br /></td></tr>
<tr class="separator:ga976717e2d78b52aec5e8d9657093a5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02ce3d553e7a40dea59c0593305a5018"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SEQUENTIAL.html#ga02ce3d553e7a40dea59c0593305a5018">foedus::storage::sequential::kRootPageHeaderSize</a> = 56</td></tr>
<tr class="memdesc:ga02ce3d553e7a40dea59c0593305a5018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte size of header in each root page of sequential storage.  <a href="group__SEQUENTIAL.html#ga02ce3d553e7a40dea59c0593305a5018">More...</a><br /></td></tr>
<tr class="separator:ga02ce3d553e7a40dea59c0593305a5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720e1cafc9a6f0cc3f9cca92bb6a9295"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SEQUENTIAL.html#ga720e1cafc9a6f0cc3f9cca92bb6a9295">foedus::storage::sequential::kRootPageMaxHeadPointers</a> = (<a class="el" href="group__STORAGE.html#ga1a3c05fe1d44455fc3e761947c6e21e6">foedus::storage::kPageSize</a> - kRootPageHeaderSize) / sizeof(HeadPagePointer)</td></tr>
<tr class="memdesc:ga720e1cafc9a6f0cc3f9cca92bb6a9295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of head pointers in one root page.  <a href="group__SEQUENTIAL.html#ga720e1cafc9a6f0cc3f9cca92bb6a9295">More...</a><br /></td></tr>
<tr class="separator:ga720e1cafc9a6f0cc3f9cca92bb6a9295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafcea33deca8f70e529945c9fac70947"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SEQUENTIAL.html#gaafcea33deca8f70e529945c9fac70947">foedus::storage::sequential::kRootPageDataSize</a> = <a class="el" href="group__STORAGE.html#ga1a3c05fe1d44455fc3e761947c6e21e6">foedus::storage::kPageSize</a> - kRootPageHeaderSize</td></tr>
<tr class="memdesc:gaafcea33deca8f70e529945c9fac70947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte size of data region in each root page of sequential storage.  <a href="group__SEQUENTIAL.html#gaafcea33deca8f70e529945c9fac70947">More...</a><br /></td></tr>
<tr class="separator:gaafcea33deca8f70e529945c9fac70947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1057c10c8c5cf6c6cdb2b56fa4ee237a"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SEQUENTIAL.html#ga1057c10c8c5cf6c6cdb2b56fa4ee237a">foedus::storage::sequential::kPointerPageCount</a> = 1U &lt;&lt; 6</td></tr>
<tr class="memdesc:ga1057c10c8c5cf6c6cdb2b56fa4ee237a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each poiner page can contain 2^10 pointers (as the node is implicit, PagePoolOffset suffices) and we can have at most 2^16 cores.  <a href="group__SEQUENTIAL.html#ga1057c10c8c5cf6c6cdb2b56fa4ee237a">More...</a><br /></td></tr>
<tr class="separator:ga1057c10c8c5cf6c6cdb2b56fa4ee237a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structfoedus_1_1storage_1_1sequential_1_1SequentialComposer_1_1RootInfoPage" id="structfoedus_1_1storage_1_1sequential_1_1SequentialComposer_1_1RootInfoPage"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct foedus::storage::sequential::SequentialComposer::RootInfoPage</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Output of one <a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialComposer.html#a3e005713f9a1c12bb2a4771a192b47a5">compose()</a> call, which are then combined in <a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialComposer.html#a91db842a6ef8780d3fe4ba2f0f625da7">construct_root()</a>. </p>
<p>Each <a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialComposer.html#a3e005713f9a1c12bb2a4771a192b47a5">compose()</a> returns just one pointer to a head page. </p>

<p>Definition at line <a class="el" href="sequential__composer__impl_8hpp_source.html#l00066">66</a> of file <a class="el" href="sequential__composer__impl_8hpp_source.html">sequential_composer_impl.hpp</a>.</p>
</div><div class="dynheader">
Collaboration diagram for foedus::storage::sequential::SequentialComposer::RootInfoPage:</div>
<div class="dyncontent">
<div class="center"><img src="structfoedus_1_1storage_1_1sequential_1_1SequentialComposer_1_1RootInfoPage__coll__graph.png" border="0" usemap="#foedus_1_1storage_1_1sequential_1_1SequentialComposer_1_1RootInfoPage_coll__map" alt="Collaboration graph"/></div>
<map name="foedus_1_1storage_1_1sequential_1_1SequentialComposer_1_1RootInfoPage_coll__map" id="foedus_1_1storage_1_1sequential_1_1SequentialComposer_1_1RootInfoPage_coll__map">
<area shape="rect" id="node2" href="group__SEQUENTIAL.html#structfoedus_1_1storage_1_1sequential_1_1HeadPagePointer" title="Each pointer to a snapshot head page comes with a bit more information to help reading. " alt="" coords="5,303,184,344"/>
<area shape="rect" id="node3" href="classfoedus_1_1Epoch.html" title="Represents a time epoch. " alt="" coords="42,199,147,225"/>
<area shape="rect" id="node4" href="structfoedus_1_1storage_1_1PageHeader.html" title="Just a marker to denote that a memory region represents a data page. " alt="" coords="209,310,399,337"/>
<area shape="rect" id="node5" href="structfoedus_1_1assorted_1_1ProbCounter.html" title="Implements a probabilistic counter [Morris 1978]. " alt="" coords="187,199,386,225"/>
<area shape="rect" id="node6" href="structfoedus_1_1storage_1_1PageVersion.html" title="Just a synonym of XctId to be used as a page lock mechanism. " alt="" coords="411,199,603,225"/>
<area shape="rect" id="node7" href="structfoedus_1_1storage_1_1PageVersionStatus.html" title="foedus::storage::PageVersion\lStatus" alt="" coords="340,95,532,136"/>
<area shape="rect" id="node8" href="structfoedus_1_1xct_1_1McsWwLock.html" title="An exclusive&#45;only (WW) MCS lock data structure. " alt="" coords="557,102,726,129"/>
<area shape="rect" id="node9" href="structfoedus_1_1xct_1_1McsWwBlockData.html" title="Exclusive&#45;only (WW) MCS lock classes. " alt="" coords="541,5,742,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2fd4b93b8d7dbb9a5a3fcd1ffc080a4f"></a>char</td>
<td class="fieldname">
filler_[<a class="el" href="group__STORAGE.html#ga1a3c05fe1d44455fc3e761947c6e21e6">kPageSize</a>-sizeof(<a class="el" href="structfoedus_1_1storage_1_1PageHeader.html">PageHeader</a>)-sizeof(<a class="el" href="group__SEQUENTIAL.html#structfoedus_1_1storage_1_1sequential_1_1HeadPagePointer">HeadPagePointer</a>)]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a87cb2500cd342741a1480c5a98684bea"></a><a class="el" href="structfoedus_1_1storage_1_1PageHeader.html">PageHeader</a></td>
<td class="fieldname">
header_</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad2911952580c94d35fa06f390221735c"></a><a class="el" href="group__SEQUENTIAL.html#structfoedus_1_1storage_1_1sequential_1_1HeadPagePointer">HeadPagePointer</a></td>
<td class="fieldname">
pointer_</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structfoedus_1_1storage_1_1sequential_1_1HeadPagePointer" id="structfoedus_1_1storage_1_1sequential_1_1HeadPagePointer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct foedus::storage::sequential::HeadPagePointer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Each pointer to a snapshot head page comes with a bit more information to help reading. </p>

<p>Definition at line <a class="el" href="sequential__id_8hpp_source.html#l00066">66</a> of file <a class="el" href="sequential__id_8hpp_source.html">sequential_id.hpp</a>.</p>
</div><div class="dynheader">
Collaboration diagram for foedus::storage::sequential::HeadPagePointer:</div>
<div class="dyncontent">
<div class="center"><img src="structfoedus_1_1storage_1_1sequential_1_1HeadPagePointer__coll__graph.png" border="0" usemap="#foedus_1_1storage_1_1sequential_1_1HeadPagePointer_coll__map" alt="Collaboration graph"/></div>
<map name="foedus_1_1storage_1_1sequential_1_1HeadPagePointer_coll__map" id="foedus_1_1storage_1_1sequential_1_1HeadPagePointer_coll__map">
<area shape="rect" id="node2" href="classfoedus_1_1Epoch.html" title="Represents a time epoch. " alt="" coords="42,5,147,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a390e37d32fc780b33c275d823a0252d0"></a><a class="el" href="classfoedus_1_1Epoch.html">Epoch</a></td>
<td class="fieldname">
from_epoch_</td>
<td class="fielddoc">
Inclusive beginning of epochs in the pointed pages. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a75a68e47be84f5bb3823a96ed9f9d9c0"></a>uint64_t</td>
<td class="fieldname">
page_count_</td>
<td class="fielddoc">
In a sequential storage, all pages from the head page is guaranteed to be contiguous (that's how <a class="el" href="classfoedus_1_1storage_1_1sequential_1_1SequentialComposer.html" title="Composer for an sequential storage. ">SequentialComposer</a> write them out). <p>This enables us to read a large number of sequential pages in one-go rather than reading one-page at a time. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a76772fd31b6b9141b6081ba0d025cc44"></a><a class="el" href="group__STORAGE.html#ga629d4b8103bfb83ef9c11b842a4fd398">SnapshotPagePointer</a></td>
<td class="fieldname">
page_id_</td>
<td class="fielddoc">
ID of the page that begins the linked list. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aaf06363722dfd1d8976fe040502569e4"></a><a class="el" href="classfoedus_1_1Epoch.html">Epoch</a></td>
<td class="fieldname">
to_epoch_</td>
<td class="fielddoc">
Exclusive end of epochs in the pointed pages. </td></tr>
</table>

</div>
</div>
<a name="structfoedus_1_1storage_1_1sequential_1_1SequentialStoragePimpl_1_1PointerPage" id="structfoedus_1_1storage_1_1sequential_1_1SequentialStoragePimpl_1_1PointerPage"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct foedus::storage::sequential::SequentialStoragePimpl::PointerPage</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sequential__storage__pimpl_8hpp_source.html#l00141">141</a> of file <a class="el" href="sequential__storage__pimpl_8hpp_source.html">sequential_storage_pimpl.hpp</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1e571fc655b7991d9a6c621d2050488e"></a>PagePoolOffset</td>
<td class="fieldname">
pointers_[<a class="el" href="namespacefoedus_1_1storage_1_1sequential.html#a2363c4f0602921e9a5a00167ae915ea5">kPointersPerPage</a>]</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga45253b9b10362dcea0c1c313dd4cdd28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t foedus::storage::sequential::kDataSize = <a class="el" href="group__STORAGE.html#ga1a3c05fe1d44455fc3e761947c6e21e6">foedus::storage::kPageSize</a> - kHeaderSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte size of data region in each data page of sequential storage. </p>

<p>Definition at line <a class="el" href="sequential__id_8hpp_source.html#l00048">48</a> of file <a class="el" href="sequential__id_8hpp_source.html">sequential_id.hpp</a>.</p>

<p>Referenced by <a class="el" href="sequential__page__impl_8hpp_source.html#l00155">foedus::storage::sequential::SequentialPage::append_record_nosync()</a>, <a class="el" href="sequential__page__impl_8hpp_source.html#l00081">foedus::storage::sequential::SequentialPage::assert_consistent()</a>, <a class="el" href="sequential__page__impl_8hpp_source.html#l00184">foedus::storage::sequential::SequentialPage::can_insert_record()</a>, <a class="el" href="sequential__cursor_8hpp_source.html#l00364">foedus::storage::sequential::SequentialRecordBatch::get_owner_id_from_offset()</a>, <a class="el" href="sequential__cursor_8hpp_source.html#l00368">foedus::storage::sequential::SequentialRecordBatch::get_payload_from_offset()</a>, <a class="el" href="sequential__page__impl_8hpp_source.html#l00086">foedus::storage::sequential::SequentialPage::get_payload_length()</a>, and <a class="el" href="sequential__page__impl_8hpp_source.html#l00094">foedus::storage::sequential::SequentialPage::set_payload_length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga133b3b55748b6abc8d3e28e4204753a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t foedus::storage::sequential::kHeaderSize = 64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte size of header in each data page of sequential storage. </p>

<p>Definition at line <a class="el" href="sequential__id_8hpp_source.html#l00043">43</a> of file <a class="el" href="sequential__id_8hpp_source.html">sequential_id.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga976717e2d78b52aec5e8d9657093a5e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t foedus::storage::sequential::kMaxPayload = kDataSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Payload must be shorter than this length. </p>

<p>Definition at line <a class="el" href="sequential__id_8hpp_source.html#l00054">54</a> of file <a class="el" href="sequential__id_8hpp_source.html">sequential_id.hpp</a>.</p>

<p>Referenced by <a class="el" href="sequential__storage__pimpl_8cpp_source.html#l00056">foedus::storage::sequential::SequentialStorage::append_record()</a>, and <a class="el" href="sequential__log__types_8hpp_source.html#l00129">foedus::storage::sequential::SequentialAppendLogType::assert_valid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga36d21c8cb7de29e785b06a6f4ac3355a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t foedus::storage::sequential::kMaxSlots = 1 &lt;&lt; 15</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We have to represent the record count in 15 bits. </p>

<p>Definition at line <a class="el" href="sequential__id_8hpp_source.html#l00038">38</a> of file <a class="el" href="sequential__id_8hpp_source.html">sequential_id.hpp</a>.</p>

<p>Referenced by <a class="el" href="sequential__page__impl_8hpp_source.html#l00155">foedus::storage::sequential::SequentialPage::append_record_nosync()</a>, and <a class="el" href="sequential__page__impl_8hpp_source.html#l00184">foedus::storage::sequential::SequentialPage::can_insert_record()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1057c10c8c5cf6c6cdb2b56fa4ee237a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t foedus::storage::sequential::kPointerPageCount = 1U &lt;&lt; 6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each poiner page can contain 2^10 pointers (as the node is implicit, PagePoolOffset suffices) and we can have at most 2^16 cores. </p>
<p>Thus we have 2^6 pointers here. This means we can waste 64*2=128 volatile pages (=512kb) per one sequential storage.. shouldn't be a big issue. </p>

<p>Definition at line <a class="el" href="sequential__id_8hpp_source.html#l00104">104</a> of file <a class="el" href="sequential__id_8hpp_source.html">sequential_id.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaafcea33deca8f70e529945c9fac70947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t foedus::storage::sequential::kRootPageDataSize = <a class="el" href="group__STORAGE.html#ga1a3c05fe1d44455fc3e761947c6e21e6">foedus::storage::kPageSize</a> - kRootPageHeaderSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte size of data region in each root page of sequential storage. </p>

<p>Definition at line <a class="el" href="sequential__id_8hpp_source.html#l00095">95</a> of file <a class="el" href="sequential__id_8hpp_source.html">sequential_id.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga02ce3d553e7a40dea59c0593305a5018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t foedus::storage::sequential::kRootPageHeaderSize = 56</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte size of header in each root page of sequential storage. </p>

<p>Definition at line <a class="el" href="sequential__id_8hpp_source.html#l00060">60</a> of file <a class="el" href="sequential__id_8hpp_source.html">sequential_id.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga720e1cafc9a6f0cc3f9cca92bb6a9295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t foedus::storage::sequential::kRootPageMaxHeadPointers = (<a class="el" href="group__STORAGE.html#ga1a3c05fe1d44455fc3e761947c6e21e6">foedus::storage::kPageSize</a> - kRootPageHeaderSize) / sizeof(HeadPagePointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of head pointers in one root page. </p>

<p>Definition at line <a class="el" href="sequential__id_8hpp_source.html#l00089">89</a> of file <a class="el" href="sequential__id_8hpp_source.html">sequential_id.hpp</a>.</p>

<p>Referenced by <a class="el" href="sequential__composer__impl_8cpp_source.html#l00230">foedus::storage::sequential::SequentialComposer::construct_root()</a>, and <a class="el" href="sequential__page__impl_8hpp_source.html#l00265">foedus::storage::sequential::SequentialRootPage::set_pointers()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
